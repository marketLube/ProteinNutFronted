<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="./src/fonts.css" />
    <link rel="stylesheet" href="./css/index.css" />
    <link rel="stylesheet" href="./css/utility.css" />
    <title>Protein Nut</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>

    <script>
      function smoothScroll() {
        let scrollAmount = 0;
        let scrollVelocity = 0;
        let isScrolling = false;
        let lastTouchY = 0;
        let lastScrollTime = Date.now();
        const throttleDelay = 40;

        // Adjusted momentum constants
        const FRICTION = 0.99; // Increased friction for longer continuation (closer to 1 = less friction)
        const MOMENTUM_MULTIPLIER = 0.2; // Increased for more momentum
        const VELOCITY_THRESHOLD = 0.1; // Lowered threshold to allow longer continuation
        const SCROLL_MULTIPLIER = 1.6; // Increased for stronger initial scroll
        const CONTINUATION_BOOST = 0.9; // Added boost factor for end-of-scroll continuation

        function throttle(callback, delay) {
          let timeoutId;
          let lastCallTime = 0;

          return function (...args) {
            const currentTime = Date.now();

            if (currentTime - lastCallTime < delay) {
              clearTimeout(timeoutId);
              timeoutId = setTimeout(() => {
                lastCallTime = currentTime;
                callback.apply(this, args);
              }, delay);
              return;
            }

            lastCallTime = currentTime;
            callback.apply(this, args);
          };
        }

        function handleScroll(delta) {
          const currentTime = Date.now();
          const elapsed = currentTime - lastScrollTime;

          // Enhanced velocity calculation with smoother acceleration
          const newVelocity =
            (delta * SCROLL_MULTIPLIER) / Math.max(elapsed, 16);
          scrollVelocity = scrollVelocity * 0.7 + newVelocity * 0.3; // Smoother velocity blending

          // Add to scroll amount
          scrollAmount += delta * SCROLL_MULTIPLIER;

          lastScrollTime = currentTime;

          if (!isScrolling) {
            isScrolling = true;
            requestAnimationFrame(smoothStep);
          }
        }

        function applyMomentum() {
          // Enhanced momentum application
          if (Math.abs(scrollVelocity) > VELOCITY_THRESHOLD * 2) {
            // Apply continuation boost when velocity is significant
            scrollAmount +=
              scrollVelocity * MOMENTUM_MULTIPLIER * CONTINUATION_BOOST;
          } else {
            scrollAmount += scrollVelocity * MOMENTUM_MULTIPLIER;
          }

          // Gradual velocity reduction
          scrollVelocity *= FRICTION;

          // Prevent infinite small scrolling
          if (Math.abs(scrollVelocity) < VELOCITY_THRESHOLD) {
            scrollVelocity *= 0.95; // Gradual fadeout
          }
        }

        function smoothStep() {
          if (
            Math.abs(scrollAmount) > 0.01 ||
            Math.abs(scrollVelocity) > VELOCITY_THRESHOLD
          ) {
            // More gradual scroll step calculation
            const scrollStep = scrollAmount * 0.15; // Reduced from 0.2 for smoother movement

            // Apply the scroll
            window.scrollBy(0, scrollStep);

            // Gradual scroll amount reduction
            scrollAmount -= scrollStep;

            // Apply enhanced momentum effects
            applyMomentum();

            requestAnimationFrame(smoothStep);
          } else {
            // Apply final continuation when scrolling ends
            if (Math.abs(scrollVelocity) > VELOCITY_THRESHOLD * 0.5) {
              scrollAmount += scrollVelocity * CONTINUATION_BOOST;
              requestAnimationFrame(smoothStep);
            } else {
              // Reset values when scrolling truly ends
              scrollAmount = 0;
              scrollVelocity = 0;
              isScrolling = false;
            }
          }
        }

        const throttledScroll = throttle((delta) => {
          handleScroll(delta);
        }, throttleDelay);

        // Wheel event handler
        window.addEventListener(
          "wheel",
          (event) => {
            event.preventDefault();
            throttledScroll(event.deltaY);
          },
          { passive: false }
        );

        // Touch event handlers with enhanced momentum
        window.addEventListener("touchstart", (event) => {
          lastTouchY = event.touches[0].clientY;
          // Preserve some velocity on touch start for smoother transitions
          scrollVelocity *= 0.5;
        });

        window.addEventListener("touchmove", (event) => {
          const currentTouchY = event.touches[0].clientY;
          const deltaY = lastTouchY - currentTouchY;
          throttledScroll(deltaY);
          lastTouchY = currentTouchY;
        });

        window.addEventListener("touchend", () => {
          // Enhanced final momentum on touch end
          scrollVelocity *= MOMENTUM_MULTIPLIER * CONTINUATION_BOOST;
          lastTouchY = 0;
        });
      }

      // Only initialize on desktop
      smoothScroll();
    </script>
  </body>
</html>
