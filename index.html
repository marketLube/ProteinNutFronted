<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="./src/fonts.css" />
    <link rel="stylesheet" href="./css/index.css" />
    <link rel="stylesheet" href="./css/utility.css" />
    <script defer src="//www.instagram.com/embed.js"></script>
    <title>Protein Nut</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
    <!-- <script async src="//www.instagram.com/embed.js"></script> -->

    <script>
      function smoothScroll() {
        let scrollAmount = 0;
        let scrollVelocity = 0;
        let isScrolling = false;
        let lastTouchY = 0;
        let lastScrollTime = Date.now();
        const throttleDelay = 30; // Adjusted throttle for delayed responsiveness

        // Momentum constants
        const FRICTION = 0.9; // Lower friction for gradual slowing down
        const MOMENTUM_MULTIPLIER = 0.8; // Adjusted for smoother deceleration
        const VELOCITY_THRESHOLD = 0.1; // Lower threshold to stop when near-zero
        const SCROLL_MULTIPLIER = 0.5; // Reduced for smoother initial scroll

        function throttle(callback, delay) {
          let timeoutId;
          let lastCallTime = 0;

          return function (...args) {
            const currentTime = Date.now();

            if (currentTime - lastCallTime < delay) {
              clearTimeout(timeoutId);
              timeoutId = setTimeout(() => {
                lastCallTime = currentTime;
                callback.apply(this, args);
              }, delay);
              return;
            }

            lastCallTime = currentTime;
            callback.apply(this, args);
          };
        }

        function handleScroll(delta) {
          const currentTime = Date.now();
          const elapsed = currentTime - lastScrollTime;

          // Calculate new velocity based on delta and elapsed time
          const newVelocity =
            (delta * SCROLL_MULTIPLIER) / Math.max(elapsed, 16);
          scrollVelocity = scrollVelocity * 0.5 + newVelocity * 0.5;

          // Add to scroll amount
          scrollAmount += delta * SCROLL_MULTIPLIER;

          lastScrollTime = currentTime;

          if (!isScrolling) {
            isScrolling = true;
            requestAnimationFrame(smoothStep);
          }
        }

        function applyMomentum() {
          // Apply momentum to scroll amount
          scrollAmount += scrollVelocity * MOMENTUM_MULTIPLIER;
          // Apply friction to velocity and ensure it reduces to 0
          scrollVelocity *= FRICTION;

          // Prevent infinite small scrolling by checking velocity threshold
          if (Math.abs(scrollVelocity) < VELOCITY_THRESHOLD) {
            scrollVelocity = 0;
          }
        }

        function smoothStep() {
          if (
            Math.abs(scrollAmount) > 0.01 ||
            Math.abs(scrollVelocity) > VELOCITY_THRESHOLD
          ) {
            const scrollStep = scrollAmount * 0.2;

            // Apply the scroll
            window.scrollBy(0, scrollStep);

            // Reduce scroll amount
            scrollAmount -= scrollStep;

            // Apply momentum effects
            applyMomentum();

            requestAnimationFrame(smoothStep);
          } else {
            // Reset values when scrolling ends
            scrollAmount = 0;
            scrollVelocity = 0;
            isScrolling = false;
          }
        }

        const throttledScroll = throttle((delta) => {
          handleScroll(delta);
        }, throttleDelay);

        // Enhanced wheel event handler
        window.addEventListener(
          "wheel",
          (event) => {
            event.preventDefault();
            throttledScroll(event.deltaY);
          },
          { passive: false }
        );

        // Enhanced touch event handlers
        window.addEventListener("touchstart", (event) => {
          lastTouchY = event.touches[0].clientY;
          // Reset velocity on touch start
          scrollVelocity = 0;
        });

        window.addEventListener("touchmove", (event) => {
          const currentTouchY = event.touches[0].clientY;
          const deltaY = lastTouchY - currentTouchY;
          throttledScroll(deltaY);
          lastTouchY = currentTouchY;
        });

        window.addEventListener("touchend", () => {
          // Add final momentum on touch end
          scrollVelocity *= MOMENTUM_MULTIPLIER;
          lastTouchY = 0;
        });
      }

      // Only initialize on desktop
      window.innerWidth >= 768 && smoothScroll();
    </script>
  </body>
</html>
